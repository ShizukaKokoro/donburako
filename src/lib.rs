//! Donburako
//!
//! データ駆動のワークフローを作成するためのライブラリ。
//! ワークフローは、ノードとエッジから構成される有向グラフで表現される。
//! ノードは、ワークフローのステップを表し、エッジはノード間の依存関係を表す。
//! 依存関係のないノードは並列に実行されるため、ワークフローの実行は効率的に行われる。
//!
//! # 概要
//!
//! ## コンポーネント
//!
//! ### ノード
//!
//! 実行されるタスクを表す。
//! 非同期に実行されるため、 IO や通信などの、 CPU バウンドでない処理を効率的に並列実行できる。
//! CPU バウンドかどうかを判断でき、バウンドしている場合は、ブロッキングスレッドを生成して並列実行する。そうでない場合は、非同期タスクとして実行する。
//! 実行可能になると、ノードはキューに追加され、最大の並列実行数を超えないように実行される。
//! 全てのノードのハンドルを `select!` マクロで一定時間ごとにチェックすることで、ノードの実行状況を監視できる。
//!
//! 入力ノードはワークフローのたった一つの入り口であり、ワークフローの開始は入力ノードが完了することで可能になる。
//! 出力ノードはワークフローのたった一つの出口であり、出力ノードが完了することでワークフローは終了する。
//!
//! ### エッジ
//!
//! ノード間の依存関係を表す。
//! データ一つにつき、一つのエッジが存在する。そのデータがどこから来るか、どこに行くかを表す。
//! 一つのノードが複数のエッジを前にも後にも持つことができる。これにより、複数の引数と複数の戻り値を扱うことができる。
//!
//! ### ワークフロー
//!
//! ノードとエッジから構成される有向グラフで表現される。
//! ノードは、ワークフローのステップとして全て保存され、未完了のノードが存在する限り、ワークフローは実行され続ける。
//! 自身が依存しているノードが全て完了している場合、初めて実行可能になる。保存しているインデックスによって、メモリと計算量がトレードオフになる。
//!
//! ### プロセッサー
//!
//! ノードを実行するためのプロセッサー。
//! ノードの実行数を制限し、並列実行を効率的に行う。
//! 複数のワークフローを同時に実行できるように、実行中のワークフローを管理する。
//! 実行するノードをワークフローから取得し、種類に応じて非同期スレッドかブロッキングスレッドで実行する。
//! 実行が完了したら、エッジにデータを紐付け、次のノードを実行する。
//! ワークフローの実行は、非同期タスクとして実行されるため、ワークフローの実行中に別のワークフローの実行を開始できる。

#![warn(missing_docs, rustdoc::missing_crate_level_docs)]
